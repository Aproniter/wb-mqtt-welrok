# Описание тестов и инструкция по запуску

Этот файл описывает существующие тесты в репозитории и шаги для локального запуска.

Кратко:

- Файлы с тестами находятся в папке `tests/`.
- Основные тесты: `tests/test_main.py`, `tests/test_mqtt_client.py`.

## Описание тестов

### `tests/test_mqtt_client.py`

Тестирует класс `MQTTClient` — обёртку над paho-mqtt для работы с MQTT-брокером:

- Генерация уникальных client_id с случайными суффиксами
- Инициализация с различными типами брокеров (Unix-socket по умолчанию, TCP, WebSockets)
- Парсинг URL с кредами (username/password)
- Запуск и остановка клиента (threaded/non-threaded режимы)
- Обработка успешного/неуспешного подключения
- Обработка ошибок подключения и переподключения
- Настройка автоматического реконнекта с задержками
- Интеграционные тесты с реальным брокером (пропущены по умолчанию)

### `tests/test_main.py`

Тестирует основные компоненты системы (`WelrokDevice`, `MQTTDevice`, `WelrokClient`) — логику управления устройствами, парсинг состояний, интеграцию с MQTT.

## Тестирование

### Подготовка окружения:

1. Создайте и активируйте виртуальное окружение (рекомендуется):

```bash
python3 -m venv .venv
source .venv/bin/activate
```

2. Установите пакет проекта в режиме разработки и pytest:

```bash
pip install -e .
pip install pytest
pip install legacy-cgi

```

### Запуск тестов:

- Запустить все тесты:

```bash
pytest -q
```

- Запустить тесты в конкретном файле:

```bash
pytest tests/test_mqtt_client.py -q
```

- Запустить интеграционные тесты (требуют реального MQTT-брокера):

```bash
# 1. Запустите mosquitto (если еще не запущен)
sudo systemctl start mosquitto

# 2. Временно уберите декоратор @pytest.mark.skip в тестах:
#    - test_real_connection
#    - test_reconnect_on_disconnect
# Или используйте параметр для игнорирования skip:
pytest tests/test_mqtt_client.py --run-skipped -k "Integration"

# Альтернативно: закомментируйте @pytest.mark.skip и запустите:
pytest tests/test_mqtt_client.py::TestMQTTClientIntegration -v
```

### Интерпретация результатов:

При запуске pytest выводит статистику в формате:

```
14 passed, 2 skipped, 1 warning in 0.20s
```

**Статусы:**
- `passed` — тесты прошли успешно ✓
- `failed` — тесты упали, требуется исправление (pytest покажет трейсбек с деталями ошибки)
- `skipped` — тесты пропущены (например, интеграционные тесты, требующие внешних сервисов)
- `warnings` — предупреждения (не критично, но можно изучить; обычно это deprecation warnings из зависимостей)

**При падении теста:**
1. Pytest покажет полный трейсбек с местом ошибки
2. Обратите внимание на секцию `AssertionError` — там указано, что именно не совпало с ожиданием
3. Используйте `-s` для вывода логов/принтов из теста для детальной отладки
4. Используйте `-k test_name` для запуска только конкретного упавшего теста

**Пример успешного прогона:**
```bash
$ pytest -q
......................                                    [100%]
31 passed, 2 skipped, 1 warning in 0.22s
```

### Параметры полезные при отладке:

- `-q` — компактный вывод;
- `-s` — не подавлять вывод в stdout/stderr (полезно для отладочных print/log);
- `-k <expr>` — запуск тестов, имена которых соответствуют выражению `expr`;
- `--maxfail=1` — остановить после первой неудачи.

### Покрытие (опционально):

```bash
pip install coverage
coverage run -m pytest
coverage report -m
```

### Особенности, которые стоит учесть:

- Некоторые тесты могут требовать наличия MQTT-брокера или внешних сервисов. Если тесты для `mqtt_client` интеграционные и требуют реального брокера, можно поставить локальный Mosquitto:

```bash
# на Debian/Ubuntu
sudo apt update && sudo apt install -y mosquitto
sudo systemctl start mosquitto
```

- Однако большинство модульных тестов используют мокирование и не требуют реальных сетевых подключений. В случае неясностей смотрите тесты в `tests/` — они показывают ожидания и используемую конфигурацию.

### Полезные команды CI-стиля:

```bash
# компактный запуск в CI
pytest --maxfail=1 --disable-warnings -q
```

